// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        v6.32.1
// source: schema.proto

package schema

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SchemaType enum representing different data types
type SchemaType int32

const (
	SchemaType_SCHEMA_TYPE_UNSPECIFIED SchemaType = 0
	SchemaType_INTEGER                 SchemaType = 1
	SchemaType_LONG                    SchemaType = 2
	SchemaType_FLOAT                   SchemaType = 3
	SchemaType_DOUBLE                  SchemaType = 4
	SchemaType_STRING                  SchemaType = 5
	SchemaType_OBJECT                  SchemaType = 6
	SchemaType_ARRAY                   SchemaType = 7
	SchemaType_BOOLEAN                 SchemaType = 8
	SchemaType_NULL                    SchemaType = 9
)

// Enum value maps for SchemaType.
var (
	SchemaType_name = map[int32]string{
		0: "SCHEMA_TYPE_UNSPECIFIED",
		1: "INTEGER",
		2: "LONG",
		3: "FLOAT",
		4: "DOUBLE",
		5: "STRING",
		6: "OBJECT",
		7: "ARRAY",
		8: "BOOLEAN",
		9: "NULL",
	}
	SchemaType_value = map[string]int32{
		"SCHEMA_TYPE_UNSPECIFIED": 0,
		"INTEGER":                 1,
		"LONG":                    2,
		"FLOAT":                   3,
		"DOUBLE":                  4,
		"STRING":                  5,
		"OBJECT":                  6,
		"ARRAY":                   7,
		"BOOLEAN":                 8,
		"NULL":                    9,
	}
)

func (x SchemaType) Enum() *SchemaType {
	p := new(SchemaType)
	*p = x
	return p
}

func (x SchemaType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SchemaType) Descriptor() protoreflect.EnumDescriptor {
	return file_schema_proto_enumTypes[0].Descriptor()
}

func (SchemaType) Type() protoreflect.EnumType {
	return &file_schema_proto_enumTypes[0]
}

func (x SchemaType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SchemaType.Descriptor instead.
func (SchemaType) EnumDescriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{0}
}

// StringFormat enum for string validation formats
type StringFormat int32

const (
	StringFormat_STRING_FORMAT_UNSPECIFIED StringFormat = 0
	StringFormat_DATETIME                  StringFormat = 1
	StringFormat_TIME                      StringFormat = 2
	StringFormat_DATE                      StringFormat = 3
	StringFormat_EMAIL                     StringFormat = 4
	StringFormat_REGEX                     StringFormat = 5
)

// Enum value maps for StringFormat.
var (
	StringFormat_name = map[int32]string{
		0: "STRING_FORMAT_UNSPECIFIED",
		1: "DATETIME",
		2: "TIME",
		3: "DATE",
		4: "EMAIL",
		5: "REGEX",
	}
	StringFormat_value = map[string]int32{
		"STRING_FORMAT_UNSPECIFIED": 0,
		"DATETIME":                  1,
		"TIME":                      2,
		"DATE":                      3,
		"EMAIL":                     4,
		"REGEX":                     5,
	}
)

func (x StringFormat) Enum() *StringFormat {
	p := new(StringFormat)
	*p = x
	return p
}

func (x StringFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StringFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_schema_proto_enumTypes[1].Descriptor()
}

func (StringFormat) Type() protoreflect.EnumType {
	return &file_schema_proto_enumTypes[1]
}

func (x StringFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StringFormat.Descriptor instead.
func (StringFormat) EnumDescriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{1}
}

// AdditionalType represents additional properties or items configuration
type AdditionalType struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*AdditionalType_BooleanValue
	//	*AdditionalType_SchemaValue
	Value         isAdditionalType_Value `protobuf_oneof:"value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AdditionalType) Reset() {
	*x = AdditionalType{}
	mi := &file_schema_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdditionalType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdditionalType) ProtoMessage() {}

func (x *AdditionalType) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdditionalType.ProtoReflect.Descriptor instead.
func (*AdditionalType) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{0}
}

func (x *AdditionalType) GetValue() isAdditionalType_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *AdditionalType) GetBooleanValue() bool {
	if x != nil {
		if x, ok := x.Value.(*AdditionalType_BooleanValue); ok {
			return x.BooleanValue
		}
	}
	return false
}

func (x *AdditionalType) GetSchemaValue() *Schema {
	if x != nil {
		if x, ok := x.Value.(*AdditionalType_SchemaValue); ok {
			return x.SchemaValue
		}
	}
	return nil
}

type isAdditionalType_Value interface {
	isAdditionalType_Value()
}

type AdditionalType_BooleanValue struct {
	BooleanValue bool `protobuf:"varint,1,opt,name=boolean_value,json=booleanValue,proto3,oneof"`
}

type AdditionalType_SchemaValue struct {
	SchemaValue *Schema `protobuf:"bytes,2,opt,name=schema_value,json=schemaValue,proto3,oneof"`
}

func (*AdditionalType_BooleanValue) isAdditionalType_Value() {}

func (*AdditionalType_SchemaValue) isAdditionalType_Value() {}

// SchemaDetails contains metadata and UI-specific information for schemas
type SchemaDetails struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	PreferredComponent string                 `protobuf:"bytes,1,opt,name=preferred_component,json=preferredComponent,proto3" json:"preferred_component,omitempty"`
	ValidationMessages map[string]string      `protobuf:"bytes,2,rep,name=validation_messages,json=validationMessages,proto3" json:"validation_messages,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Properties         map[string]*anypb.Any  `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	StyleProperties    map[string]*anypb.Any  `protobuf:"bytes,4,rep,name=style_properties,json=styleProperties,proto3" json:"style_properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Order              int32                  `protobuf:"varint,5,opt,name=order,proto3" json:"order,omitempty"`
	Label              string                 `protobuf:"bytes,6,opt,name=label,proto3" json:"label,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *SchemaDetails) Reset() {
	*x = SchemaDetails{}
	mi := &file_schema_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaDetails) ProtoMessage() {}

func (x *SchemaDetails) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaDetails.ProtoReflect.Descriptor instead.
func (*SchemaDetails) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{1}
}

func (x *SchemaDetails) GetPreferredComponent() string {
	if x != nil {
		return x.PreferredComponent
	}
	return ""
}

func (x *SchemaDetails) GetValidationMessages() map[string]string {
	if x != nil {
		return x.ValidationMessages
	}
	return nil
}

func (x *SchemaDetails) GetProperties() map[string]*anypb.Any {
	if x != nil {
		return x.Properties
	}
	return nil
}

func (x *SchemaDetails) GetStyleProperties() map[string]*anypb.Any {
	if x != nil {
		return x.StyleProperties
	}
	return nil
}

func (x *SchemaDetails) GetOrder() int32 {
	if x != nil {
		return x.Order
	}
	return 0
}

func (x *SchemaDetails) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

// Type represents a single schema type
type SingleType struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          SchemaType             `protobuf:"varint,1,opt,name=type,proto3,enum=schema.SchemaType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SingleType) Reset() {
	*x = SingleType{}
	mi := &file_schema_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SingleType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SingleType) ProtoMessage() {}

func (x *SingleType) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SingleType.ProtoReflect.Descriptor instead.
func (*SingleType) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{2}
}

func (x *SingleType) GetType() SchemaType {
	if x != nil {
		return x.Type
	}
	return SchemaType_SCHEMA_TYPE_UNSPECIFIED
}

// MultipleType represents multiple possible schema types
type MultipleType struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Types         []SchemaType           `protobuf:"varint,1,rep,packed,name=types,proto3,enum=schema.SchemaType" json:"types,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultipleType) Reset() {
	*x = MultipleType{}
	mi := &file_schema_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultipleType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultipleType) ProtoMessage() {}

func (x *MultipleType) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultipleType.ProtoReflect.Descriptor instead.
func (*MultipleType) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{3}
}

func (x *MultipleType) GetTypes() []SchemaType {
	if x != nil {
		return x.Types
	}
	return nil
}

// Type union for representing either single or multiple types
type Type struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to TypeUnion:
	//
	//	*Type_SingleType
	//	*Type_MultipleType
	TypeUnion     isType_TypeUnion `protobuf_oneof:"type_union"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Type) Reset() {
	*x = Type{}
	mi := &file_schema_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Type) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Type) ProtoMessage() {}

func (x *Type) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Type.ProtoReflect.Descriptor instead.
func (*Type) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{4}
}

func (x *Type) GetTypeUnion() isType_TypeUnion {
	if x != nil {
		return x.TypeUnion
	}
	return nil
}

func (x *Type) GetSingleType() *SingleType {
	if x != nil {
		if x, ok := x.TypeUnion.(*Type_SingleType); ok {
			return x.SingleType
		}
	}
	return nil
}

func (x *Type) GetMultipleType() *MultipleType {
	if x != nil {
		if x, ok := x.TypeUnion.(*Type_MultipleType); ok {
			return x.MultipleType
		}
	}
	return nil
}

type isType_TypeUnion interface {
	isType_TypeUnion()
}

type Type_SingleType struct {
	SingleType *SingleType `protobuf:"bytes,1,opt,name=single_type,json=singleType,proto3,oneof"`
}

type Type_MultipleType struct {
	MultipleType *MultipleType `protobuf:"bytes,2,opt,name=multiple_type,json=multipleType,proto3,oneof"`
}

func (*Type_SingleType) isType_TypeUnion() {}

func (*Type_MultipleType) isType_TypeUnion() {}

// ArraySchemaType represents array item schemas (single or tuple)
type ArraySchemaType struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to SchemaUnion:
	//
	//	*ArraySchemaType_SingleSchema
	//	*ArraySchemaType_TupleSchema
	SchemaUnion   isArraySchemaType_SchemaUnion `protobuf_oneof:"schema_union"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArraySchemaType) Reset() {
	*x = ArraySchemaType{}
	mi := &file_schema_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArraySchemaType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArraySchemaType) ProtoMessage() {}

func (x *ArraySchemaType) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArraySchemaType.ProtoReflect.Descriptor instead.
func (*ArraySchemaType) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{5}
}

func (x *ArraySchemaType) GetSchemaUnion() isArraySchemaType_SchemaUnion {
	if x != nil {
		return x.SchemaUnion
	}
	return nil
}

func (x *ArraySchemaType) GetSingleSchema() *Schema {
	if x != nil {
		if x, ok := x.SchemaUnion.(*ArraySchemaType_SingleSchema); ok {
			return x.SingleSchema
		}
	}
	return nil
}

func (x *ArraySchemaType) GetTupleSchema() *TupleSchema {
	if x != nil {
		if x, ok := x.SchemaUnion.(*ArraySchemaType_TupleSchema); ok {
			return x.TupleSchema
		}
	}
	return nil
}

type isArraySchemaType_SchemaUnion interface {
	isArraySchemaType_SchemaUnion()
}

type ArraySchemaType_SingleSchema struct {
	SingleSchema *Schema `protobuf:"bytes,1,opt,name=single_schema,json=singleSchema,proto3,oneof"`
}

type ArraySchemaType_TupleSchema struct {
	TupleSchema *TupleSchema `protobuf:"bytes,2,opt,name=tuple_schema,json=tupleSchema,proto3,oneof"`
}

func (*ArraySchemaType_SingleSchema) isArraySchemaType_SchemaUnion() {}

func (*ArraySchemaType_TupleSchema) isArraySchemaType_SchemaUnion() {}

// TupleSchema represents a tuple of schemas for array items
type TupleSchema struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schemas       []*Schema              `protobuf:"bytes,1,rep,name=schemas,proto3" json:"schemas,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TupleSchema) Reset() {
	*x = TupleSchema{}
	mi := &file_schema_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TupleSchema) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TupleSchema) ProtoMessage() {}

func (x *TupleSchema) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TupleSchema.ProtoReflect.Descriptor instead.
func (*TupleSchema) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{6}
}

func (x *TupleSchema) GetSchemas() []*Schema {
	if x != nil {
		return x.Schemas
	}
	return nil
}

// Main Schema message representing a JSON schema
type Schema struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Basic identification
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Version   int32  `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	Ref       string `protobuf:"bytes,4,opt,name=ref,proto3" json:"ref,omitempty"`
	// Type information
	Type  *Type     `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty"`
	AnyOf []*Schema `protobuf:"bytes,6,rep,name=any_of,json=anyOf,proto3" json:"any_of,omitempty"`
	AllOf []*Schema `protobuf:"bytes,7,rep,name=all_of,json=allOf,proto3" json:"all_of,omitempty"`
	OneOf []*Schema `protobuf:"bytes,8,rep,name=one_of,json=oneOf,proto3" json:"one_of,omitempty"`
	Not   *Schema   `protobuf:"bytes,9,opt,name=not,proto3" json:"not,omitempty"`
	// Documentation and examples
	Description  string       `protobuf:"bytes,10,opt,name=description,proto3" json:"description,omitempty"`
	Examples     []*anypb.Any `protobuf:"bytes,11,rep,name=examples,proto3" json:"examples,omitempty"`
	DefaultValue *anypb.Any   `protobuf:"bytes,12,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Comment      string       `protobuf:"bytes,13,opt,name=comment,proto3" json:"comment,omitempty"`
	Enums        []*anypb.Any `protobuf:"bytes,14,rep,name=enums,proto3" json:"enums,omitempty"`
	Constant     *anypb.Any   `protobuf:"bytes,15,opt,name=constant,proto3" json:"constant,omitempty"`
	// String validation
	Pattern   string       `protobuf:"bytes,16,opt,name=pattern,proto3" json:"pattern,omitempty"`
	Format    StringFormat `protobuf:"varint,17,opt,name=format,proto3,enum=schema.StringFormat" json:"format,omitempty"`
	MinLength int32        `protobuf:"varint,18,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	MaxLength int32        `protobuf:"varint,19,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	// Number validation
	MultipleOf       float64 `protobuf:"fixed64,20,opt,name=multiple_of,json=multipleOf,proto3" json:"multiple_of,omitempty"`
	Minimum          float64 `protobuf:"fixed64,21,opt,name=minimum,proto3" json:"minimum,omitempty"`
	Maximum          float64 `protobuf:"fixed64,22,opt,name=maximum,proto3" json:"maximum,omitempty"`
	ExclusiveMinimum float64 `protobuf:"fixed64,23,opt,name=exclusive_minimum,json=exclusiveMinimum,proto3" json:"exclusive_minimum,omitempty"`
	ExclusiveMaximum float64 `protobuf:"fixed64,24,opt,name=exclusive_maximum,json=exclusiveMaximum,proto3" json:"exclusive_maximum,omitempty"`
	// Object validation
	Properties           map[string]*Schema `protobuf:"bytes,25,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	AdditionalProperties *AdditionalType    `protobuf:"bytes,26,opt,name=additional_properties,json=additionalProperties,proto3" json:"additional_properties,omitempty"`
	Required             []string           `protobuf:"bytes,27,rep,name=required,proto3" json:"required,omitempty"`
	PropertyNames        *Schema            `protobuf:"bytes,28,opt,name=property_names,json=propertyNames,proto3" json:"property_names,omitempty"`
	MinProperties        int32              `protobuf:"varint,29,opt,name=min_properties,json=minProperties,proto3" json:"min_properties,omitempty"`
	MaxProperties        int32              `protobuf:"varint,30,opt,name=max_properties,json=maxProperties,proto3" json:"max_properties,omitempty"`
	PatternProperties    map[string]*Schema `protobuf:"bytes,31,rep,name=pattern_properties,json=patternProperties,proto3" json:"pattern_properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Array validation
	Items           *ArraySchemaType `protobuf:"bytes,32,opt,name=items,proto3" json:"items,omitempty"`
	AdditionalItems *AdditionalType  `protobuf:"bytes,33,opt,name=additional_items,json=additionalItems,proto3" json:"additional_items,omitempty"`
	Contains        *Schema          `protobuf:"bytes,34,opt,name=contains,proto3" json:"contains,omitempty"`
	MinContains     int32            `protobuf:"varint,35,opt,name=min_contains,json=minContains,proto3" json:"min_contains,omitempty"`
	MaxContains     int32            `protobuf:"varint,36,opt,name=max_contains,json=maxContains,proto3" json:"max_contains,omitempty"`
	MinItems        int32            `protobuf:"varint,37,opt,name=min_items,json=minItems,proto3" json:"min_items,omitempty"`
	MaxItems        int32            `protobuf:"varint,38,opt,name=max_items,json=maxItems,proto3" json:"max_items,omitempty"`
	UniqueItems     bool             `protobuf:"varint,39,opt,name=unique_items,json=uniqueItems,proto3" json:"unique_items,omitempty"`
	// Definitions and metadata
	Defs          map[string]*Schema `protobuf:"bytes,40,rep,name=defs,proto3" json:"defs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Permission    string             `protobuf:"bytes,41,opt,name=permission,proto3" json:"permission,omitempty"`
	Details       *SchemaDetails     `protobuf:"bytes,42,opt,name=details,proto3" json:"details,omitempty"`
	ViewDetails   *SchemaDetails     `protobuf:"bytes,43,opt,name=view_details,json=viewDetails,proto3" json:"view_details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Schema) Reset() {
	*x = Schema{}
	mi := &file_schema_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Schema) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Schema) ProtoMessage() {}

func (x *Schema) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Schema.ProtoReflect.Descriptor instead.
func (*Schema) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{7}
}

func (x *Schema) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *Schema) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Schema) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *Schema) GetRef() string {
	if x != nil {
		return x.Ref
	}
	return ""
}

func (x *Schema) GetType() *Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *Schema) GetAnyOf() []*Schema {
	if x != nil {
		return x.AnyOf
	}
	return nil
}

func (x *Schema) GetAllOf() []*Schema {
	if x != nil {
		return x.AllOf
	}
	return nil
}

func (x *Schema) GetOneOf() []*Schema {
	if x != nil {
		return x.OneOf
	}
	return nil
}

func (x *Schema) GetNot() *Schema {
	if x != nil {
		return x.Not
	}
	return nil
}

func (x *Schema) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Schema) GetExamples() []*anypb.Any {
	if x != nil {
		return x.Examples
	}
	return nil
}

func (x *Schema) GetDefaultValue() *anypb.Any {
	if x != nil {
		return x.DefaultValue
	}
	return nil
}

func (x *Schema) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *Schema) GetEnums() []*anypb.Any {
	if x != nil {
		return x.Enums
	}
	return nil
}

func (x *Schema) GetConstant() *anypb.Any {
	if x != nil {
		return x.Constant
	}
	return nil
}

func (x *Schema) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

func (x *Schema) GetFormat() StringFormat {
	if x != nil {
		return x.Format
	}
	return StringFormat_STRING_FORMAT_UNSPECIFIED
}

func (x *Schema) GetMinLength() int32 {
	if x != nil {
		return x.MinLength
	}
	return 0
}

func (x *Schema) GetMaxLength() int32 {
	if x != nil {
		return x.MaxLength
	}
	return 0
}

func (x *Schema) GetMultipleOf() float64 {
	if x != nil {
		return x.MultipleOf
	}
	return 0
}

func (x *Schema) GetMinimum() float64 {
	if x != nil {
		return x.Minimum
	}
	return 0
}

func (x *Schema) GetMaximum() float64 {
	if x != nil {
		return x.Maximum
	}
	return 0
}

func (x *Schema) GetExclusiveMinimum() float64 {
	if x != nil {
		return x.ExclusiveMinimum
	}
	return 0
}

func (x *Schema) GetExclusiveMaximum() float64 {
	if x != nil {
		return x.ExclusiveMaximum
	}
	return 0
}

func (x *Schema) GetProperties() map[string]*Schema {
	if x != nil {
		return x.Properties
	}
	return nil
}

func (x *Schema) GetAdditionalProperties() *AdditionalType {
	if x != nil {
		return x.AdditionalProperties
	}
	return nil
}

func (x *Schema) GetRequired() []string {
	if x != nil {
		return x.Required
	}
	return nil
}

func (x *Schema) GetPropertyNames() *Schema {
	if x != nil {
		return x.PropertyNames
	}
	return nil
}

func (x *Schema) GetMinProperties() int32 {
	if x != nil {
		return x.MinProperties
	}
	return 0
}

func (x *Schema) GetMaxProperties() int32 {
	if x != nil {
		return x.MaxProperties
	}
	return 0
}

func (x *Schema) GetPatternProperties() map[string]*Schema {
	if x != nil {
		return x.PatternProperties
	}
	return nil
}

func (x *Schema) GetItems() *ArraySchemaType {
	if x != nil {
		return x.Items
	}
	return nil
}

func (x *Schema) GetAdditionalItems() *AdditionalType {
	if x != nil {
		return x.AdditionalItems
	}
	return nil
}

func (x *Schema) GetContains() *Schema {
	if x != nil {
		return x.Contains
	}
	return nil
}

func (x *Schema) GetMinContains() int32 {
	if x != nil {
		return x.MinContains
	}
	return 0
}

func (x *Schema) GetMaxContains() int32 {
	if x != nil {
		return x.MaxContains
	}
	return 0
}

func (x *Schema) GetMinItems() int32 {
	if x != nil {
		return x.MinItems
	}
	return 0
}

func (x *Schema) GetMaxItems() int32 {
	if x != nil {
		return x.MaxItems
	}
	return 0
}

func (x *Schema) GetUniqueItems() bool {
	if x != nil {
		return x.UniqueItems
	}
	return false
}

func (x *Schema) GetDefs() map[string]*Schema {
	if x != nil {
		return x.Defs
	}
	return nil
}

func (x *Schema) GetPermission() string {
	if x != nil {
		return x.Permission
	}
	return ""
}

func (x *Schema) GetDetails() *SchemaDetails {
	if x != nil {
		return x.Details
	}
	return nil
}

func (x *Schema) GetViewDetails() *SchemaDetails {
	if x != nil {
		return x.ViewDetails
	}
	return nil
}

var File_schema_proto protoreflect.FileDescriptor

const file_schema_proto_rawDesc = "" +
	"\n" +
	"\fschema.proto\x12\x06schema\x1a\x19google/protobuf/any.proto\"u\n" +
	"\x0eAdditionalType\x12%\n" +
	"\rboolean_value\x18\x01 \x01(\bH\x00R\fbooleanValue\x123\n" +
	"\fschema_value\x18\x02 \x01(\v2\x0e.schema.SchemaH\x00R\vschemaValueB\a\n" +
	"\x05value\"\xe0\x04\n" +
	"\rSchemaDetails\x12/\n" +
	"\x13preferred_component\x18\x01 \x01(\tR\x12preferredComponent\x12^\n" +
	"\x13validation_messages\x18\x02 \x03(\v2-.schema.SchemaDetails.ValidationMessagesEntryR\x12validationMessages\x12E\n" +
	"\n" +
	"properties\x18\x03 \x03(\v2%.schema.SchemaDetails.PropertiesEntryR\n" +
	"properties\x12U\n" +
	"\x10style_properties\x18\x04 \x03(\v2*.schema.SchemaDetails.StylePropertiesEntryR\x0fstyleProperties\x12\x14\n" +
	"\x05order\x18\x05 \x01(\x05R\x05order\x12\x14\n" +
	"\x05label\x18\x06 \x01(\tR\x05label\x1aE\n" +
	"\x17ValidationMessagesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aS\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12*\n" +
	"\x05value\x18\x02 \x01(\v2\x14.google.protobuf.AnyR\x05value:\x028\x01\x1aX\n" +
	"\x14StylePropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12*\n" +
	"\x05value\x18\x02 \x01(\v2\x14.google.protobuf.AnyR\x05value:\x028\x01\"4\n" +
	"\n" +
	"SingleType\x12&\n" +
	"\x04type\x18\x01 \x01(\x0e2\x12.schema.SchemaTypeR\x04type\"8\n" +
	"\fMultipleType\x12(\n" +
	"\x05types\x18\x01 \x03(\x0e2\x12.schema.SchemaTypeR\x05types\"\x88\x01\n" +
	"\x04Type\x125\n" +
	"\vsingle_type\x18\x01 \x01(\v2\x12.schema.SingleTypeH\x00R\n" +
	"singleType\x12;\n" +
	"\rmultiple_type\x18\x02 \x01(\v2\x14.schema.MultipleTypeH\x00R\fmultipleTypeB\f\n" +
	"\n" +
	"type_union\"\x92\x01\n" +
	"\x0fArraySchemaType\x125\n" +
	"\rsingle_schema\x18\x01 \x01(\v2\x0e.schema.SchemaH\x00R\fsingleSchema\x128\n" +
	"\ftuple_schema\x18\x02 \x01(\v2\x13.schema.TupleSchemaH\x00R\vtupleSchemaB\x0e\n" +
	"\fschema_union\"7\n" +
	"\vTupleSchema\x12(\n" +
	"\aschemas\x18\x01 \x03(\v2\x0e.schema.SchemaR\aschemas\"\xc7\x0f\n" +
	"\x06Schema\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespace\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x03 \x01(\x05R\aversion\x12\x10\n" +
	"\x03ref\x18\x04 \x01(\tR\x03ref\x12 \n" +
	"\x04type\x18\x05 \x01(\v2\f.schema.TypeR\x04type\x12%\n" +
	"\x06any_of\x18\x06 \x03(\v2\x0e.schema.SchemaR\x05anyOf\x12%\n" +
	"\x06all_of\x18\a \x03(\v2\x0e.schema.SchemaR\x05allOf\x12%\n" +
	"\x06one_of\x18\b \x03(\v2\x0e.schema.SchemaR\x05oneOf\x12 \n" +
	"\x03not\x18\t \x01(\v2\x0e.schema.SchemaR\x03not\x12 \n" +
	"\vdescription\x18\n" +
	" \x01(\tR\vdescription\x120\n" +
	"\bexamples\x18\v \x03(\v2\x14.google.protobuf.AnyR\bexamples\x129\n" +
	"\rdefault_value\x18\f \x01(\v2\x14.google.protobuf.AnyR\fdefaultValue\x12\x18\n" +
	"\acomment\x18\r \x01(\tR\acomment\x12*\n" +
	"\x05enums\x18\x0e \x03(\v2\x14.google.protobuf.AnyR\x05enums\x120\n" +
	"\bconstant\x18\x0f \x01(\v2\x14.google.protobuf.AnyR\bconstant\x12\x18\n" +
	"\apattern\x18\x10 \x01(\tR\apattern\x12,\n" +
	"\x06format\x18\x11 \x01(\x0e2\x14.schema.StringFormatR\x06format\x12\x1d\n" +
	"\n" +
	"min_length\x18\x12 \x01(\x05R\tminLength\x12\x1d\n" +
	"\n" +
	"max_length\x18\x13 \x01(\x05R\tmaxLength\x12\x1f\n" +
	"\vmultiple_of\x18\x14 \x01(\x01R\n" +
	"multipleOf\x12\x18\n" +
	"\aminimum\x18\x15 \x01(\x01R\aminimum\x12\x18\n" +
	"\amaximum\x18\x16 \x01(\x01R\amaximum\x12+\n" +
	"\x11exclusive_minimum\x18\x17 \x01(\x01R\x10exclusiveMinimum\x12+\n" +
	"\x11exclusive_maximum\x18\x18 \x01(\x01R\x10exclusiveMaximum\x12>\n" +
	"\n" +
	"properties\x18\x19 \x03(\v2\x1e.schema.Schema.PropertiesEntryR\n" +
	"properties\x12K\n" +
	"\x15additional_properties\x18\x1a \x01(\v2\x16.schema.AdditionalTypeR\x14additionalProperties\x12\x1a\n" +
	"\brequired\x18\x1b \x03(\tR\brequired\x125\n" +
	"\x0eproperty_names\x18\x1c \x01(\v2\x0e.schema.SchemaR\rpropertyNames\x12%\n" +
	"\x0emin_properties\x18\x1d \x01(\x05R\rminProperties\x12%\n" +
	"\x0emax_properties\x18\x1e \x01(\x05R\rmaxProperties\x12T\n" +
	"\x12pattern_properties\x18\x1f \x03(\v2%.schema.Schema.PatternPropertiesEntryR\x11patternProperties\x12-\n" +
	"\x05items\x18  \x01(\v2\x17.schema.ArraySchemaTypeR\x05items\x12A\n" +
	"\x10additional_items\x18! \x01(\v2\x16.schema.AdditionalTypeR\x0fadditionalItems\x12*\n" +
	"\bcontains\x18\" \x01(\v2\x0e.schema.SchemaR\bcontains\x12!\n" +
	"\fmin_contains\x18# \x01(\x05R\vminContains\x12!\n" +
	"\fmax_contains\x18$ \x01(\x05R\vmaxContains\x12\x1b\n" +
	"\tmin_items\x18% \x01(\x05R\bminItems\x12\x1b\n" +
	"\tmax_items\x18& \x01(\x05R\bmaxItems\x12!\n" +
	"\funique_items\x18' \x01(\bR\vuniqueItems\x12,\n" +
	"\x04defs\x18( \x03(\v2\x18.schema.Schema.DefsEntryR\x04defs\x12\x1e\n" +
	"\n" +
	"permission\x18) \x01(\tR\n" +
	"permission\x12/\n" +
	"\adetails\x18* \x01(\v2\x15.schema.SchemaDetailsR\adetails\x128\n" +
	"\fview_details\x18+ \x01(\v2\x15.schema.SchemaDetailsR\vviewDetails\x1aM\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.schema.SchemaR\x05value:\x028\x01\x1aT\n" +
	"\x16PatternPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.schema.SchemaR\x05value:\x028\x01\x1aG\n" +
	"\tDefsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12$\n" +
	"\x05value\x18\x02 \x01(\v2\x0e.schema.SchemaR\x05value:\x028\x01*\x91\x01\n" +
	"\n" +
	"SchemaType\x12\x1b\n" +
	"\x17SCHEMA_TYPE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aINTEGER\x10\x01\x12\b\n" +
	"\x04LONG\x10\x02\x12\t\n" +
	"\x05FLOAT\x10\x03\x12\n" +
	"\n" +
	"\x06DOUBLE\x10\x04\x12\n" +
	"\n" +
	"\x06STRING\x10\x05\x12\n" +
	"\n" +
	"\x06OBJECT\x10\x06\x12\t\n" +
	"\x05ARRAY\x10\a\x12\v\n" +
	"\aBOOLEAN\x10\b\x12\b\n" +
	"\x04NULL\x10\t*e\n" +
	"\fStringFormat\x12\x1d\n" +
	"\x19STRING_FORMAT_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bDATETIME\x10\x01\x12\b\n" +
	"\x04TIME\x10\x02\x12\b\n" +
	"\x04DATE\x10\x03\x12\t\n" +
	"\x05EMAIL\x10\x04\x12\t\n" +
	"\x05REGEX\x10\x05B\x19Z\x17/proto/generated/schemab\x06proto3"

var (
	file_schema_proto_rawDescOnce sync.Once
	file_schema_proto_rawDescData []byte
)

func file_schema_proto_rawDescGZIP() []byte {
	file_schema_proto_rawDescOnce.Do(func() {
		file_schema_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_schema_proto_rawDesc), len(file_schema_proto_rawDesc)))
	})
	return file_schema_proto_rawDescData
}

var file_schema_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_schema_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_schema_proto_goTypes = []any{
	(SchemaType)(0),         // 0: schema.SchemaType
	(StringFormat)(0),       // 1: schema.StringFormat
	(*AdditionalType)(nil),  // 2: schema.AdditionalType
	(*SchemaDetails)(nil),   // 3: schema.SchemaDetails
	(*SingleType)(nil),      // 4: schema.SingleType
	(*MultipleType)(nil),    // 5: schema.MultipleType
	(*Type)(nil),            // 6: schema.Type
	(*ArraySchemaType)(nil), // 7: schema.ArraySchemaType
	(*TupleSchema)(nil),     // 8: schema.TupleSchema
	(*Schema)(nil),          // 9: schema.Schema
	nil,                     // 10: schema.SchemaDetails.ValidationMessagesEntry
	nil,                     // 11: schema.SchemaDetails.PropertiesEntry
	nil,                     // 12: schema.SchemaDetails.StylePropertiesEntry
	nil,                     // 13: schema.Schema.PropertiesEntry
	nil,                     // 14: schema.Schema.PatternPropertiesEntry
	nil,                     // 15: schema.Schema.DefsEntry
	(*anypb.Any)(nil),       // 16: google.protobuf.Any
}
var file_schema_proto_depIdxs = []int32{
	9,  // 0: schema.AdditionalType.schema_value:type_name -> schema.Schema
	10, // 1: schema.SchemaDetails.validation_messages:type_name -> schema.SchemaDetails.ValidationMessagesEntry
	11, // 2: schema.SchemaDetails.properties:type_name -> schema.SchemaDetails.PropertiesEntry
	12, // 3: schema.SchemaDetails.style_properties:type_name -> schema.SchemaDetails.StylePropertiesEntry
	0,  // 4: schema.SingleType.type:type_name -> schema.SchemaType
	0,  // 5: schema.MultipleType.types:type_name -> schema.SchemaType
	4,  // 6: schema.Type.single_type:type_name -> schema.SingleType
	5,  // 7: schema.Type.multiple_type:type_name -> schema.MultipleType
	9,  // 8: schema.ArraySchemaType.single_schema:type_name -> schema.Schema
	8,  // 9: schema.ArraySchemaType.tuple_schema:type_name -> schema.TupleSchema
	9,  // 10: schema.TupleSchema.schemas:type_name -> schema.Schema
	6,  // 11: schema.Schema.type:type_name -> schema.Type
	9,  // 12: schema.Schema.any_of:type_name -> schema.Schema
	9,  // 13: schema.Schema.all_of:type_name -> schema.Schema
	9,  // 14: schema.Schema.one_of:type_name -> schema.Schema
	9,  // 15: schema.Schema.not:type_name -> schema.Schema
	16, // 16: schema.Schema.examples:type_name -> google.protobuf.Any
	16, // 17: schema.Schema.default_value:type_name -> google.protobuf.Any
	16, // 18: schema.Schema.enums:type_name -> google.protobuf.Any
	16, // 19: schema.Schema.constant:type_name -> google.protobuf.Any
	1,  // 20: schema.Schema.format:type_name -> schema.StringFormat
	13, // 21: schema.Schema.properties:type_name -> schema.Schema.PropertiesEntry
	2,  // 22: schema.Schema.additional_properties:type_name -> schema.AdditionalType
	9,  // 23: schema.Schema.property_names:type_name -> schema.Schema
	14, // 24: schema.Schema.pattern_properties:type_name -> schema.Schema.PatternPropertiesEntry
	7,  // 25: schema.Schema.items:type_name -> schema.ArraySchemaType
	2,  // 26: schema.Schema.additional_items:type_name -> schema.AdditionalType
	9,  // 27: schema.Schema.contains:type_name -> schema.Schema
	15, // 28: schema.Schema.defs:type_name -> schema.Schema.DefsEntry
	3,  // 29: schema.Schema.details:type_name -> schema.SchemaDetails
	3,  // 30: schema.Schema.view_details:type_name -> schema.SchemaDetails
	16, // 31: schema.SchemaDetails.PropertiesEntry.value:type_name -> google.protobuf.Any
	16, // 32: schema.SchemaDetails.StylePropertiesEntry.value:type_name -> google.protobuf.Any
	9,  // 33: schema.Schema.PropertiesEntry.value:type_name -> schema.Schema
	9,  // 34: schema.Schema.PatternPropertiesEntry.value:type_name -> schema.Schema
	9,  // 35: schema.Schema.DefsEntry.value:type_name -> schema.Schema
	36, // [36:36] is the sub-list for method output_type
	36, // [36:36] is the sub-list for method input_type
	36, // [36:36] is the sub-list for extension type_name
	36, // [36:36] is the sub-list for extension extendee
	0,  // [0:36] is the sub-list for field type_name
}

func init() { file_schema_proto_init() }
func file_schema_proto_init() {
	if File_schema_proto != nil {
		return
	}
	file_schema_proto_msgTypes[0].OneofWrappers = []any{
		(*AdditionalType_BooleanValue)(nil),
		(*AdditionalType_SchemaValue)(nil),
	}
	file_schema_proto_msgTypes[4].OneofWrappers = []any{
		(*Type_SingleType)(nil),
		(*Type_MultipleType)(nil),
	}
	file_schema_proto_msgTypes[5].OneofWrappers = []any{
		(*ArraySchemaType_SingleSchema)(nil),
		(*ArraySchemaType_TupleSchema)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_schema_proto_rawDesc), len(file_schema_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   14,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_schema_proto_goTypes,
		DependencyIndexes: file_schema_proto_depIdxs,
		EnumInfos:         file_schema_proto_enumTypes,
		MessageInfos:      file_schema_proto_msgTypes,
	}.Build()
	File_schema_proto = out.File
	file_schema_proto_goTypes = nil
	file_schema_proto_depIdxs = nil
}
