# KIRun Language Overview

## Introduction

KIRun is a specialized programming language designed for no-code/low-code environments, particularly focused on UI interactions, data manipulation, and business logic execution. The language combines declarative syntax with functional programming concepts to provide a powerful yet accessible way to build applications.

## Core Philosophy

KIRun is built around several key principles:

- **Function-First Approach**: Everything in KIRun is a function call, making the language predictable and composable
- **Event-Driven Architecture**: Functions generate events that trigger subsequent operations
- **Data Store Abstraction**: No direct variable references; instead, data is accessed through various stores (Context, Arguments, Steps, Page, Store, etc.)
- **Indentation-Based Structure**: Uses indentation (tabs or 4 spaces) to define code blocks and relationships
- **Schema-Driven**: Strong typing through JSON schemas and built-in type definitions

## Language Characteristics

### Case Sensitivity

All keywords in KIRun are **case-sensitive**. Function names, parameter names, and keywords must be written exactly as specified.

### Comments

KIRun supports two types of comments:

- **Line comments**: `/* This is a comment */` - can span multiple lines
- **End-of-line comments**: `/* Comment */` - optional and don't require closing

Comments are ignored by the interpreter and don't affect program execution.

### Indentation

Indentation is crucial in KIRun and serves multiple purposes:

- Defines nested blocks within functions
- Indicates event-driven execution flow
- Establishes parent-child relationships between steps

## Data Stores

KIRun uses a store-based architecture where data is accessed through different stores rather than direct variable references:

### Built-in Stores

- **Context**: Runtime execution store for creating and manipulating variables
- **Arguments**: Read-only store for accessing function parameters
- **Steps**: Store for data generated by step events (overridden on multiple triggers)

### External Stores

- **Page**: UI page data when used in web applications
- **Store**: Application-level data storage
- **Authorities**: Security context for user permissions

## Function Structure

### Function Signature Block

Every KIRun function begins with a signature block that defines:

```kirun
FUNCTION functionName
    NAMESPACE namespaceName  /* Optional */
    PARAMETERS
        paramName {
            "type": "INTEGER"
        }
    EVENTS
        eventName
            result AS ARRAY OF INTEGER
```

### Logic Block

The main execution logic follows the `LOGIC` keyword:

```kirun
LOGIC
stepName: System.Function.Call(parameter = value)
    eventName
        nestedStep: System.AnotherFunction.Call()
```

## Expression Language

KIRun supports rich expressions for data manipulation:

### String Operations

```kirun
"Mr." + Page.form.name  /* String concatenation */
```

### Array Operations

```kirun
Store.user.authorities.[0..{{Page.size}}]  /* Array slicing with dynamic range */
```

### Mathematical Expressions

```kirun
(Page.benches // Page.benchesInEachRow) + (Page.benches % Page.benchesInEachRow = 0 ? 0 : 1)
```

### Conditional Expressions

```kirun
condition ? valueIfTrue : valueIfFalse
```

## Built-in Functions

KIRun provides a comprehensive set of built-in functions organized in namespaces:

### System.Context

- `Create`: Initialize variables with schemas
- `Set`: Update variable values

### System.Loop

- `RangeLoop`: Iterate over numeric ranges

### System.If

- `If`: Conditional branching with true/false events

### System.Array

- `InsertLast`: Add elements to arrays

### System.GenerateEvent

- `GenerateEvent`: Emit custom events with data

## Schema System

KIRun uses JSON Schema for type definitions with shorthand syntax:

### Basic Types

- `INTEGER`, `LONG`, `FLOAT`, `DOUBLE`
- `STRING`, `BOOLEAN`, `NULL`
- `ARRAY`, `OBJECT`

### Complex Schemas

```kirun
OBJECT OF
    name AS STRING OF MINLENGTH 3, MAXLENGTH 40,
    age AS ((INTEGER OR LONG) OF MINVALUE 0, MAXVALUE 60) OR
           (STRING OF MINLENGTH 1, MAXLENGTH 3, PATTERN "[0-9]{1,2}")
```

## Event-Driven Execution

KIRun's execution model is event-driven:

1. **Function Calls**: Generate events when executed
2. **Event Parameters**: Carry data between steps
3. **Event Flow**: Events trigger subsequent steps based on indentation
4. **Output Events**: All functions generate an `output` event upon completion

## Use Cases

KIRun is particularly well-suited for:

- **UI Logic**: Form validation, dynamic content generation
- **Data Processing**: Array manipulation, mathematical calculations
- **Business Rules**: Conditional logic, workflow automation
- **Integration**: Connecting different data sources and APIs
- **No-Code Platforms**: Providing programmability in visual builders

## Key Benefits

- **Declarative**: Focus on what to do rather than how to do it
- **Composable**: Functions can be easily combined and reused
- **Type Safe**: Strong typing prevents runtime errors
- **Event-Driven**: Natural fit for reactive programming patterns
- **Extensible**: External functions and schemas can be integrated
- **Accessible**: Simple syntax suitable for non-programmers

## Integration Points

KIRun is designed to integrate with:

- **UI Frameworks**: Through Page and Store data stores
- **Security Systems**: Via Authorities store
- **External APIs**: Through custom function repositories
- **Data Sources**: Via schema repositories
- **Runtime Environments**: Through configurable data stores

This overview provides the foundation for understanding KIRun's capabilities and design philosophy. The language combines the simplicity of no-code platforms with the power and flexibility of traditional programming languages.
