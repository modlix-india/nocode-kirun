# Kinetic Instruction Runtime - KIRun - Language Overview

## Introduction

KIRun is a **declarative, event-driven language** designed to express business logic and data-flow pipelines in a form that is equally friendly to visual drag-and-drop authoring tools and text-based programs.

KIRun is a specialized programming language designed for no-code/low-code environments, particularly focused on UI interactions, data manipulation, and business logic execution. The language combines declarative syntax with functional programming concepts to provide a powerful yet accessible way to build applications.

The programs/functions are always sorted to JSON for execution. It works primarily in three different formats.

1. Expression Mode - A single self-contained expression that evaluates to a value.
1. Function Mode - A complete function consisting of signature and logic. It comes in the following two formats
   1. Text - A text based format to specify the logic like a program.
   2. JSON - A logic graph which is ready for execution. (This is the )

## Core Philosophy

1. **Visual ⇆ Text round-tripping** &mdash; It gives the flexibility to write code in text and visualize at the same time or vice versa.
1. **Predictable side-effects** &mdash; There is no ambiguity when it comes to the flow it is always unidirectional with loops and branches.
1. **Polyglot embeddability** &mdash; Currently we have implmentations in Java and Javascript. An implementation in go is under construction. Eventually all major languages will have embeddings to include it into their workflow.
1. **Schema-driven safety** &mdash; There are no datatypes except for schemas to define complex types.
1. **Function-First Approach** &mdash; Everything in KIRun is a function call, making the language predictable and composable
1. **Event-Driven Architecture** &mdash; Functions generate events that trigger subsequent operations
1. **Data Store Abstraction**: No direct variable references; instead, data is accessed through various stores (Context, Arguments, Steps, Page, Store, etc.)

## Language Characteristics

KIRun has several distinctive characteristics that make it unique and well-suited for no-code/low-code environments:

### Function-First Architecture

Everything in KIRun is a function call. There are no direct statements or operations - all logic is expressed through function invocations with named parameters. This makes the language highly predictable and composable.

```kirun
create: System.Context.Create(name = "a", schema = (ARRAY OF INTEGER) WITH DEFAULT VALUE [])
```

### Case Sensitivity

All keywords in KIRun are **case-sensitive**. Function names, parameter names, and keywords must be written exactly as specified. Keywords like `FUNCTION`, `NAMESPACE`, `PARAMETERS`, `EVENTS`, `LOGIC`, and `REFER` must be written in uppercase.

### Indentation-Based Syntax

Like Python, KIRun relies on indentation (tabs or 4 spaces) to define program structure:

- Defines nested blocks within functions
- Indicates event-driven execution flow
- Establishes parent-child relationships between steps
- Shows which steps are triggered by specific events

```kirun
loop: System.Loop.RangeLoop(to = Arguments.n)
    iteration
        if: System.If(condition = Steps.loop.iteration.index < 2)
            true
                trueInsert: System.Array.InsertLast(source = Context.a, element = Steps.loop.iteration.index)
```

### Store-Based Data Access

Unlike traditional programming languages, KIRun has no direct variable references. All data is accessed through various stores:

- **Context**: Runtime execution store for creating and manipulating variables
- **Arguments**: Read-only store for accessing function parameters
- **Steps**: Store for data generated by step events
- **External stores**: Page, Store, Authorities (supplied at runtime)

### Step Labeling System

Each step in the logic can be labeled for easy reference:

```kirun
create: System.Context.Create(name = "a", schema = (ARRAY OF INTEGER))
loop: System.Loop.RangeLoop(to = Arguments.n)
```

Steps can also be unlabeled if they're not referenced elsewhere:

```kirun
: System.Context.Set(name = "Context.a", value = Steps.trueInsert.output.result)
```

The labels will be generated after compilation and JSON is generated from the text.

### Named Parameters

All function parameters are named, and order doesn't matter (except for variadic parameters marked with `...`):

```kirun
System.Context.Create(name = "a", schema = (ARRAY OF INTEGER) WITH DEFAULT VALUE [])
```

### Event-Driven Execution Flow

Functions generate events that trigger subsequent operations. The indentation structure shows which steps are triggered by specific events:

```kirun
if: System.If(condition = Steps.loop.iteration.index < 2)
    true
        trueInsert: System.Array.InsertLast(source = Context.a, element = Steps.loop.iteration.index)
    false
        falseInsert: System.Array.InsertLast(source = Context.a, element = Context.a[index - 1] + Context.a[index - 2])
```

### Comments

All comments are followed after the keyword COMMENT to the end of line. No multi line comments are allowed. Every step can optionally end with COMMENT keyword. It specifies the comment of that step. Comments for the function are specified at the beginning of the function. Any comments in the schema either specified using COMMENT keyword while using schema shorthand or using "comment" key in the JSON format of schema.

### Execution Dependencies

Steps can specify execution dependencies using the `AFTER` keyword:

```kirun
loop: System.Loop.RangeLoop(to = Arguments.n) AFTER Steps.create.output
```

### Declarative Nature

KIRun focuses on declaring what should happen rather than how it should happen, making it accessible to non-programmers while maintaining the power needed for complex business logic.

## Data Stores

KIRun uses a store-based architecture where data is accessed through different stores rather than direct variable references:

### Built-in Stores

- **Context**: Runtime execution store for creating and manipulating variables
- **Arguments**: Read-only store for accessing function parameters
- **Steps**: Store for data generated by step events (overridden on multiple triggers of the same event only holds the last event of the same type)

### External Stores

- **Page**: UI page data when used in web applications
- **Store**: Application-level data storage
- **Authorities**: Security context for user permissions

## Function Structure

### Function Signature Block

Every KIRun function begins with a signature block that defines:

```kirun
FUNCTION functionName
    NAMESPACE namespaceName  /* Optional */
    PARAMETERS
        paramName {
            "type": "INTEGER"
        }
    EVENTS
        eventName
            result AS ARRAY OF INTEGER
```

### Logic Block

The main execution logic follows the `LOGIC` keyword:

```kirun
LOGIC
stepName: System.Function.Call(parameter = value)
    eventName
        nestedStep: System.AnotherFunction.Call()
```

## Expression Language

KIRun supports rich expressions for data manipulation:

### String Operations

```kirun
"Mr." + Page.form.name  /* String concatenation */
```

### Array Operations

```kirun
Store.user.authorities.[0..{{Page.size}}]  /* Array slicing with dynamic range */
```

### Mathematical Expressions

```kirun
(Page.benches // Page.benchesInEachRow) + (Page.benches % Page.benchesInEachRow = 0 ? 0 : 1)
```

### Conditional Expressions

```kirun
condition ? valueIfTrue : valueIfFalse
```

## Built-in Functions

KIRun provides a comprehensive set of built-in functions organized in namespaces:

### System.Context

- `Create`: Initialize variables with schemas
- `Set`: Update variable values

### System.Loop

- `RangeLoop`: Iterate over numeric ranges

### System.If

- `If`: Conditional branching with true/false events

### System.Array

- `InsertLast`: Add elements to arrays

### System.GenerateEvent

- `GenerateEvent`: Emit custom events with data

## Schema System

KIRun uses JSON Schema for type definitions with shorthand syntax:

### Basic Types

- `INTEGER`, `LONG`, `FLOAT`, `DOUBLE`
- `STRING`, `BOOLEAN`, `NULL`
- `ARRAY`, `OBJECT`

### Complex Schemas

```kirun
OBJECT OF
    name AS STRING OF MINLENGTH 3, MAXLENGTH 40,
    age AS ((INTEGER OR LONG) OF MINVALUE 0, MAXVALUE 60) OR
           (STRING OF MINLENGTH 1, MAXLENGTH 3, PATTERN "[0-9]{1,2}")
```

## Event-Driven Execution

KIRun's execution model is event-driven:

1. **Function Calls**: Generate events when executed
2. **Event Parameters**: Carry data between steps
3. **Event Flow**: Events trigger subsequent steps based on indentation
4. **Output Events**: All functions generate an `output` event upon completion

## Use Cases

KIRun is particularly well-suited for:

- **UI Logic**: Form validation, dynamic content generation
- **Data Processing**: Array manipulation, mathematical calculations
- **Business Rules**: Conditional logic, workflow automation
- **Integration**: Connecting different data sources and APIs
- **No-Code Platforms**: Providing programmability in visual builders

## Key Benefits

- **Declarative**: Focus on what to do rather than how to do it
- **Composable**: Functions can be easily combined and reused
- **Type Safe**: Strong typing prevents runtime errors
- **Event-Driven**: Natural fit for reactive programming patterns
- **Extensible**: External functions and schemas can be integrated
- **Accessible**: Simple syntax suitable for non-programmers

## Integration Points

KIRun is designed to integrate with:

- **UI Frameworks**: Through Page and Store data stores
- **Security Systems**: Via Authorities store
- **External APIs**: Through custom function repositories
- **Data Sources**: Via schema repositories
- **Runtime Environments**: Through configurable data stores

This overview provides the foundation for understanding KIRun's capabilities and design philosophy. The language combines the simplicity of no-code platforms with the power and flexibility of traditional programming languages.
