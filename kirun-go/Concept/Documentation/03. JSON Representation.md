# JSON Representation in KIRun

## Overview

KIRun functions are always compiled from text format to JSON format before execution. This JSON representation serves as:

1. **Compilation Target**: Text programs are converted to JSON during compilation
2. **Visual Representation**: JSON format enables drag-and-drop visual editing
3. **Runtime Format**: The execution engine processes the JSON representation
4. **Storage Format**: Only the JSON version is typically saved to disk

The JSON format provides a structured, unambiguous representation of the function's logic, dependencies, and data flow.

## Function Structure Mapping

### Text to JSON Transformation

The text format:

```kirun
FUNCTION fibonacci
    NAMESPACE Math
    PARAMETERS
        n AS { "type" : "INTEGER" }
    EVENTS
        output
            result AS ARRAY OF INTEGER
LOGIC
    /* steps... */
```

Becomes the JSON structure:

```json
{
  "name": "fibonacci",
  "namespace": "Math",
  "parameters": {
    /* parameter definitions */
  },
  "events": {
    /* event definitions */
  },
  "steps": {
    /* step definitions */
  }
}
```

## Function Metadata

### Function Name and Namespace

**Text Format:**

```kirun
FUNCTION fibonacci
    NAMESPACE Math
```

**JSON Format:**

```json
{
  "name": "fibonacci",
  "namespace": "Math"
}
```

### Parameters Definition

**Text Format:**

```kirun
PARAMETERS
    n AS { "type" : "INTEGER" }
```

**JSON Format:**

```json
{
  "parameters": {
    "n": {
      "parameterName": "n",
      "schema": {
        "type": ["INTEGER"]
      }
    }
  }
}
```

### Events Definition

**Text Format:**

```kirun
EVENTS
    output
        result AS ARRAY OF INTEGER
```

**JSON Format:**

```json
{
  "events": {
    "output": {
      "name": "output",
      "parameters": {
        "result": {
          "type": ["ARRAY"],
          "items": {
            "type": ["INTEGER"]
          }
        }
      }
    }
  }
}
```

## Step Representation

### Basic Step Structure

**Text Format:**

```kirun
create: System.Context.Create(name = "a", schema = (ARRAY OF INTEGER) WITH DEFAULT VALUE [])
```

**JSON Format:**

```json
{
  "steps": {
    "create": {
      "statementName": "create",
      "name": "Create",
      "namespace": "System.Context",
      "parameterMap": {
        "name": {
          "2JUURU6NHj9voaArLv0pS8": {
            "key": "2JUURU6NHj9voaArLv0pS8",
            "type": "VALUE",
            "order": 1,
            "value": "a"
          }
        },
        "schema": {
          "2vxDXyOakSmhiUmH4CuDED": {
            "key": "2vxDXyOakSmhiUmH4CuDED",
            "type": "VALUE",
            "order": 1,
            "value": {
              "type": "ARRAY",
              "items": {
                "type": "INTEGER"
              }
            }
          }
        }
      }
    }
  }
}
```

### Step Components

1. **Statement Name**: The label assigned to the step
2. **Function Name**: The actual function being called
3. **Namespace**: The namespace of the function
4. **Parameter Map**: Named parameters with unique keys
5. **Dependencies**: Event dependencies for execution order

## Parameter Mapping

### Parameter Types

KIRun supports two types of parameters in the JSON representation:

#### VALUE Type Parameters

For literal values:

```json
{
  "key": "uniqueId",
  "type": "VALUE",
  "order": 1,
  "value": "literal_value"
}
```

#### EXPRESSION Type Parameters

For dynamic expressions:

```json
{
  "key": "uniqueId",
  "type": "EXPRESSION",
  "expression": "Arguments.n",
  "order": 1
}
```

### Parameter Examples

**Text Format:**

```kirun
loop: System.Loop.RangeLoop(to = Arguments.n)
```

**JSON Format:**

```json
{
  "loop": {
    "statementName": "loop",
    "name": "RangeLoop",
    "namespace": "System.Loop",
    "parameterMap": {
      "to": {
        "6RAIEdM1OAek2AKf64ucqM": {
          "key": "6RAIEdM1OAek2AKf64ucqM",
          "type": "EXPRESSION",
          "expression": "Arguments.n",
          "value": 1
        }
      }
    }
  }
}
```

## Event Dependencies

### Dependency Tracking

**Text Format:**

```kirun
loop: System.Loop.RangeLoop(to = Arguments.n) AFTER Steps.create.output
    iteration
        if: System.If(condition = Steps.loop.iteration.index < 2)
```

**JSON Format:**

```json
{
  "if": {
    "dependentStatements": {
      "Steps.loop.iteration": true
    }
  }
}
```

### Dependency Values

- `true`: Step executes multiple times (for each iteration of the dependency)

## Event-Driven Flow

### Text Indentation to JSON Dependencies

**Text Format:**

```kirun
if: System.If(condition = Steps.loop.iteration.index < 2)
    true
        trueInsert: System.Array.InsertLast(source = Context.a, element = Steps.loop.iteration.index)
        : System.Context.Set(name = "Context.a", value = Steps.trueInsert.output.result)
    false
        falseInsert: System.Array.InsertLast(source = Context.a, element = Context.a[index - 1] + Context.a[index - 2])
```

**JSON Format:**

```json
{
  "trueInsert": {
    "dependentStatements": {
      "Steps.if.true": true
    }
  },
  "set": {
    "dependentStatements": {
      "Steps.if.true": false
    }
  },
  "falseInsert": {
    "dependentStatements": {
      "Steps.if.false": true
    }
  }
}
```

## Unique Key Generation

### Parameter Key System

Each parameter in the JSON representation gets a unique key:

- Used for tracking parameters across visual editing
- Enables parameter reordering and modification
- Provides stable references for the visual editor

Example:

```json
{
  "name": {
    "2JUURU6NHj9voaArLv0pS8": {
      "key": "2JUURU6NHj9voaArLv0pS8",
      "type": "VALUE",
      "order": 1,
      "value": "a"
    }
  }
}
```

## Unlabeled Steps

### Auto-Generated Labels

**Text Format:**

```kirun
: System.Context.Set(name = "Context.a", value = Steps.trueInsert.output.result)
```

**JSON Format:**

```json
{
  "set": {
    "statementName": "set",
    "name": "Set",
    "namespace": "System.Context"
  }
}
```

Unlabeled steps get auto-generated labels during compilation.

## Complex Expressions

### Expression Handling

**Text Format:**

```kirun
falseInsert: System.Array.InsertLast(source = Context.a, element = Context.a[Steps.loop.iteration.index - 1] + Context.a[Steps.loop.iteration.index - 2])
```

**JSON Format:**

```json
{
  "element": {
    "53vsp50RjvhS94xdCtWWx0": {
      "key": "53vsp50RjvhS94xdCtWWx0",
      "type": "EXPRESSION",
      "expression": "Context.a[Steps.loop.iteration.index - 1] + Context.a[Steps.loop.iteration.index - 2]",
      "order": 1
    }
  }
}
```

## Event Generation

### GenerateEvent Function

**Text Format:**

```kirun
: System.GenerateEvent(results = {
    "name": "result",
    "value": Context.a
})
```

**JSON Format:**

```json
{
  "generateEvent": {
    "statementName": "generateEvent",
    "name": "GenerateEvent",
    "namespace": "System",
    "parameterMap": {
      "results": {
        "8brcu20HciA9rYDPOFeef": {
          "key": "8brcu20HciA9rYDPOFeef",
          "type": "VALUE",
          "value": {
            "name": "result",
            "value": {
              "isExpression": true,
              "value": "Context.a"
            }
          },
          "order": 1
        }
      }
    }
  }
}
```

## Visual Editor Integration

### Drag-and-Drop Workflow

1. **Visual Changes**: User modifies function in visual editor
2. **JSON Update**: Changes are applied to JSON representation
3. **Text Generation**: Text format is regenerated from JSON
4. **Compilation**: JSON is used directly for execution

### Bidirectional Synchronization

- **Text → JSON**: Compilation phase converts text to JSON
- **JSON → Text**: Visual editor generates text from JSON
- **JSON → Execution**: Runtime processes JSON directly

## Compilation Benefits

### Why JSON Representation?

1. **Unambiguous Structure**: No parsing ambiguity
2. **Visual Editing**: Direct manipulation of structure
3. **Dependency Tracking**: Explicit event dependencies
4. **Tooling Support**: Standard JSON processing tools
5. **Runtime Efficiency**: Direct execution without parsing

### Performance Advantages

- **No Runtime Parsing**: JSON is ready for execution
- **Efficient Dependency Resolution**: Pre-computed dependencies
- **Optimized Storage**: Compact representation
- **Fast Visual Updates**: Direct JSON manipulation

## Best Practices

### JSON Generation

1. **Preserve Intent**: Maintain semantic meaning from text
2. **Stable Keys**: Use consistent unique keys for parameters
3. **Dependency Accuracy**: Correctly map event dependencies
4. **Type Safety**: Preserve schema information
5. **Expression Integrity**: Maintain complex expressions

### Visual Editor Considerations

1. **User-Friendly Labels**: Auto-generate meaningful step names
2. **Dependency Visualization**: Show event flow clearly
3. **Parameter Grouping**: Group related parameters
4. **Error Handling**: Validate JSON structure
5. **Performance**: Optimize for large functions

This JSON representation system enables KIRun to provide both powerful text-based programming and intuitive visual editing, making it accessible to both developers and business users while maintaining the full power of the underlying language.
