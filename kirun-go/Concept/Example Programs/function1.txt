COMMENT Start of the function signature block. You can only one Function per file or execution block. Can have multiple sub-functions with SUBFUNCTION keyword. They are not available outside this file. Indentation is a primary part of the KIRun programs/functions. Unlike other programming languages, here we don't have direct reference to variables. Various data stores are supplied to the runtime to gain access to the data. Context, Arguments and Steps are three default stores which are part of the runtime. Context is the store which is execution. The functions System.Context.Create the variables in the Context store with the predetermined data types. System.Context.Set to manipulate the variable data in Context store. Arguments store is not for changing anything but to refer to the incoming arguments. Steps store is the store to handle the data generated by the events of each step. The data is overriden if an event is triggered multiple times. You can supply external stores to the program compiler and interpreter to retrieve the data from outside sources like Page (when used in UI for page data), Store (when used in UI for application data), Authorities (When used in context of security to find if a user has authority required). Similar to data stores, you can supply function and schema repositories. All the built-in functions and their signatures are readily available, any external functions are supplied to the runtime and compile time so the signature of each function in the form of Function Repositories. All the built-in schemas are readily available, any external schemas are supplied to the runtime and compile time in the form of Schema Repositories. FUNCTION is a key word which specifies start of a function and all keywords are case sensitive. Then followed by name of the function. Like python we rely on tab or 4 spaces to start the nested blocks, Namespace is optional. NAMESPACE is a keyword. This is parameters section of function signature block which is optional. PARAMETERS is a keyword. Observe that this comment is not ended. "n" is the name of the parameter and then follows a JSON object which specifies the schema of the parameter. Or it can be the reference to an external schema like "REFER System.integer" without double quotes. Something like "n REFER System.integer" since System.integer is not a keyword. REFER is a keyword. Since we are spraying the schema within the program we need to support, comments in between JSON too. If the parameter is a variable parameter then it is prefixed with three dots. For example "...n". This is the events section of function signature block which is optional. EVENTS is a keyword Name of the event it generates, all the functions will generate output event indicating all the execution is done and it can return multiple values like golang. Here output event is only returning one event parameter called result of type array of integers. When a function don't specify any events then also an output event is generated without any event parameters. Also shorthand format of schema definition should work. Like INTEGER, LONG, FLOAT, DOUBLE, STRING, NULL, BOOLEAN, ARRAY and OBJECT. "OBJECT OF name AS STRING OF MINLENGTH 3, MAXLENGTH 40, age AS ((INTEGER OR LONG) OF MINVALUE 0, MAXVALUE 60) OR (STRING OF MINLENGTH 1, MAXLENGTH 3, PATTERN "[0-9]{1,2}")" is the representation of { "type" : "OBJECT", "properties": { "name": {"type" : "STRING", "minLength": 1, "maxLength": 3}, "number": {"anyOf": [{"type": ["INTEGER", "LONG"], "minValue" : 0, "maxValue": 60}, { "type" : "STRING", "minLength": 1, "maxLength": 3, "pattern": "[0-9]{1,2}" }]} }}. LOGIC is a keyword which marks the beginging of the steps or statements in the function
FUNCTION fibonacci 
    NAMESPACE Math 
    PARAMETERS 
        n AS { 
            "type" : "INTEGER"  
          }
    EVENTS 
        output 
            result AS ARRAY OF INTEGER COMMENT This comment will part of the schema not the function.
LOGIC
create: System.Context.Create(name = "a", schema = (ARRAY OF INTEGER) WITH DEFAULT VALUE []) COMMENT Every line in the logic is labeled to easily access the data of the step. Since this is a lanaguage of only function calls. Variable declaration happens thru this Create function in System.Context namespace. All the parameters are named, so order don't matter, unless it is a variable parameter and multiple arguments are given conseequently then order do matter.
loop: System.Loop.RangeLoop(to = Arguments.n) AFTER Steps.create.output COMMENT Here we are executing the function called RangeLoop which emits iteration event for every number in the range. So all the steps under will be executed when the event is triggered and it's even paramters are used in the subsequent steps 
    iteration COMMENT The step loop's iteration event is intended with tab or 4 spaces. All the subsequent steps are relied on this event to be triggered.
        if: System.If(condition = Steps.loop.iteration.index < 2) COMMENT This function If generates the events true or false, and output. If the condition is true then the true event and output event are fired. If the condition is false then false event and output event are fired. 
            true
                trueInsert: System.Array.InsertLast(source = Context.a, element = Steps.loop.iteration.index)
                : System.Context.Set(name = "Context.a", value = Steps.trueInsert.output.result) COMMENT This step or statement is not labeled because it is not being refereed further in the program. 
            false
                falseInsert: System.Array.InsertLast(source = Context.a, element = Context.a[Steps.rangeLoop.iteration.index - 1] + Context.a[Steps.rangeLoop.iteration.index - 2])
                : System.Context.Set(name = "Context.a", value = Steps.falseInsert.output.result)
    output
        : System.GenerateEvent(results = {
            "name": "result",
            "value": Context.a
        }) COMMENT Every line in the logic is labeled to easily access the data of the step. Since this is a lanaguage of only function calls. Variable declaration happens thru this Create function in System.Context namespace. All the parameters are named, so order don't matter, unless it is a variable parameter and multiple arguments are given conseequently then order do matter.
